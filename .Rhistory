height.mean.F <- mean(yf)
height.mean.M <- mean(ym)
height.sd <- sd(ym)
}
model {
for (i in 1:N.F) {
yf[i] ~ dnorm(mu.F, 1/(sigma^2))
}
for (j in 1:N.M) {
ym[j] ~ dnorm(mu.M, 1/(sigma^2))
}
mu.F ~ dnorm(height.mean.F, 1/(height.sd*2)^2)
mu.M ~ dnorm(height.mean.M, 1/(height.sd*2)^2)
sigma ~ dexp(3/(height.sd*2))
}
",
data=list(
yf = gruppeF,
ym = gruppeM
),
monitor=c("mu.F", "mu.M", "sigma"),
n.chains=3,
burnin = 1000,
sample = 10000,
method="parallel"
)
view(model)
diagMCMC(model$mcmc, parName = "mu.F")
diagMCMC(model$mcmc, parName = "mu.M")
diagMCMC(model$mcmc, parName = "sigma")
posterior = as.matrix(model$mcmc)
par(mfrow=c(2,2))
plotPost(posterior[,"mu.F"], main="Gruppe Frauen, Mittelwert", xlab=bquote(mu), cenTend = "median")
plotPost(posterior[,"mu.M"], main="Gruppe MÃ¤nner, Mittelwert", xlab=bquote(mu), cenTend = "median")
plotPost(posterior[,"sigma"], main="Std.abw.", xlab=bquote(sigma), cenTend = "median")
plotPost(posterior[,"mu.F"]-posterior[,"mu.M"], main="Differenz Mittelwert A/B", xlab=bquote(mu), cenTend = "median")
# 20 Zufallszahlen einer fairen MÃ¼nze (50:50 fÃ¼r Kopf:Zahl)
# Zahl gibt Anzahl der 1er (=Kopf) pro 10 WÃ¼rfe (size) an
rbinom(20, size=10, prob = 0.5)
# 20 Zufallszahlen einer unfairen MÃ¼nze
rbinom(20, size=10, prob = 0.8)
# Verteilung
hist(rbinom(1000, size=10, prob=0.5))
# Wahrscheinlichkeit, dass bei 10 WÃ¼rfen (size) einer fairen MÃ¼nze (prob) genau 5x Kopf kommt
dbinom(x = 5, size = 10, prob = 0.5)
# Verteilung: Wie wahrscheinlich sind bei 100 WÃ¼rfen (size) einer fairen MÃ¼nze
# die einzelnen Ergebnisse (0x Kopf bis 100x Kopf)
wahrsch = dbinom(0:100, size=100, prob = 0.5)
plot(wahrsch, type='h')
# ist eine Wahrscheinlichkeitsverteilung, d.h. summe=1
sum(wahrsch)
# wie wahrscheinlich sind 61x Kopf oder Ã¶fter? (Index 61, weil Index 1 == 0x Kopf)
sum(wahrsch[61:101])
# Umgekehrter Fall (Labor):
# Fairness der MÃ¼nze unbekannt, wir sehen 60x Kopf bei 100 WÃ¼rfen
# Welche MÃ¼nzen sind am wahrscheinlichsten?
theta = seq(0,1, length.out = 200)
likely = dbinom(60, size = 100, prob = theta)
plot(theta, likely, type='l')
# bei weniger WÃ¼rfen: ungenauere Bestimmung
likely = dbinom(6, size = 10, prob = theta)
plot(theta, likely, type='l')
# Likelihood ist keine Wahrscheinlichkeitsverteilung!
sum(likely)
theta = seq(0,1, length.out = 200)
likely = dbinom(60, size = 100, prob = theta)
# Wir haben ein bestimmtes Vorwissen
prior = dbeta(theta, 3 , 3)
prior
library(ggplot2)
library(car)
library(corrplot)
library(effects)
library(pwr)
library(ROCR)
library(runjags)
library(coda)
rjags::load.module("glm")
library(akit2)
df <- read.csv('C:\\Users\\Dominik\\Downloads\\bank-promo.csv')
df$month = factor(df$month, c("jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"))
df$poutcome = factor(df$poutcome, c("unknown", "other", "failure", "success"))
# Schritt 1: Verwenden Sie nur die ersten 5000 Datensätze.
#            Erstellen Sie ein Modell für Team 1 und eines für Team 2.
#            Validieren Sie die Modelle.
dfn = df[1:5000,]
model1 = glm(y ~ month + duration + campaign + poutcome, data = dfn, family = binomial(link = "logit"))
model2 = glm(y ~ age + job + marital + education + default + balance + housing + loan, data = dfn, family = binomial(link = "logit"))
summary(model1)
#------------ Überblick verschaffen -------------#
view(dfn)
hist(dfn$job)
table(dfn$job)
table(dfn$marital)
table(dfn$education)
table(dfn$poutcome)
#age, mean = 40, min = 19, max = 93
hist(age)
#age, mean = 40, min = 19, max = 93
hist(dfn$age)
#balance, mean = 1389, min = -3372, max = 98417
hist(dfn$balance)
#duration, mean = 250sek, min = 1sek, max = 3322sek
hist(dfn$duration)
#campaign, mean = 2.8, min = 1, max = 46
hist(dfn$campaign)
summary(model2)
summary(model1)
deviance(model1)/model1$df.residual
deviance(model2)/model2$df.residual #ist unter 1. Also ok.
y.hat1 = predict(model1)
y2.hat1 = y.hat1^2
model1.test = glm(dfn$y ~ y.hat1 + y2.hat1, family = binomial(link = "logit"))
summary(model1.test)
model1.test = glm(y ~ y.hat1 + y2.hat1, data = dfn, family = binomial(link = "logit"))
summary(model1.test)
y.hat2 = predict(model2)
y2.hat2 = y.hat2^2
model2.test = glm(y ~ y.hat2 + y2.hat2, data = dfn, family = binomial(link = "logit"))
summary(model2.test)
vif(model1)
#Alle werte unter 2. Also gut.
vif(model2)
outlierTest(model1)
plot(model1, which=4)
plot(model1, which=5) #Lerverage test wichtig ist das unsere "gerade" innerhalb der
outlierTest(model2) #Zeigt keine Ausreißer an
plot(model2, which=4) #Alles sogar unter 0.05. Sehr gut.
plot(model2, which=5) #Sieht generell gut aus.
library(ROCR)
pred1 = prediction(model$fitted.values, df$fehler)
perf1 = performance(pred1, measure = 'tpr', 'fpr')
pred1 = prediction(model1$fitted.values, df$fehler)
pred1 = prediction(model1$fitted.values, dfn$fehler)
pred1 = prediction(model1$fitted.values, dfn$y)
perf1 = performance(pred1, measure = 'tpr', 'fpr')
plot(perf1, colorize=TRUE, main="ROC: Modell")
abline(0,1, lty=2)
#Sieht gut aus für model1
pred1 = prediction(model2$fitted.values, dfn$y)
perf1 = performance(pred1, measure = 'tpr', 'fpr')
plot(perf1, colorize=TRUE, main="ROC: Modell")
abline(0,1, lty=2)
#Sieht flacher aus als bei model1.
ROC(model1)
ROC(model1)
#Sieht gut aus für model1
ROC(model2)
m1.aov = Anova(model1, type=2) #--> type3 würde den Intercept mitanzeigen
ssq = m1.aov[,1]
names(ssq) = rownames(m1.aov) # Ergebnis passende Namen geben
ssq / m1.aov["Residuals",1]
Anova(model1)
m1.aov = Anova(model2, type=2) #--> type3 würde den Intercept mitanzeigen
ssq = m1.aov[,1]
names(ssq) = rownames(m1.aov) # Ergebnis passende Namen geben
ssq / m1.aov["Residuals",1]
Anova(model1)
Anova(model1, test = "Chisq")
drop1(model1)
Anova(model1)
#7.2 drop1
drop1(model1)
#7.3 anova
anova(model1, model2)
#7.4 AIC
AIC(model1, model2)
install.packages("C:/Users/Dominik/Downloads/akit2_0.2.4.tar.gz", repos = NULL, type = "source")
library(car)
library(corrplot)
library(runjags)
library(akit2)
# Daten von EU-Wahl 2014
w2014 = read.csv('C:\\Users\\Dominik\\Downloads\\Endgueltiges_Ergebnis_mit_Briefwahl_2014.csv', stringsAsFactors = F)
w2014 = w2014[,c(1:3,5:8,10,12,14,16,18,20,22,24)] # ohne Prozentspalten
colnames(w2014)[3:11] = c('Wahlberechtigte', 'abgegeben', 'ungueltig', 'gueltig',
'OEVP', 'SPOE', 'FPOE', 'GRUENE', 'BZOE')
w2014 = within(w2014, {
abgegeben = as.integer(abgegeben)
ungueltig = as.integer(ungueltig)
gueltig = as.integer(gueltig)
nicht.waehler = Wahlberechtigte - abgegeben
kleine = BZOE + REKOS + ANDERS + EUSTOP
})
# kleine Parteien weg
w2014 = w2014[,c(-11,-13,-14,-15)]
omit2014 = c(1, # Kommentarzeile
grep('^G.0000', w2014$GKZ),  # BundeslÃ¤nder
grep('^G.[A-Z]', w2014$GKZ), # Bezirke
grep('^G...99', w2014$GKZ),  # Wahlkarten (sind in Summen der StÃ¤dte enthalten)
grep('^G9..01', w2014$GKZ),  # Wien ohne Wahlkarten
grep('^G[1-7]0101', w2014$GKZ), # HauptstÃ¤dte ohne Wahlkarten
grep('G10201|G30301|G40201|G30401|G40301|G20201', w2014$GKZ) # letzte Ãberbleibsel
)
at2014 = w2014[2,]
w2014 = w2014[-omit2014,] # ohne Summenzeilen
# Daten von EU-Wahl 2019
w2019 = read.csv('C:\\Users\\Dominik\\Downloads\\Vorlaeufiges_Ergebnis_mit_Briefwahl_2019.csv', stringsAsFactors = F)
w2019 = w2019[,c(1:7,9,11,13,15,17,19)] # ohne Prozentspalten
colnames(w2019)[3:12] = c('Wahlberechtigte', 'abgegeben', 'ungueltig', 'gueltig',
'OEVP', 'SPOE', 'FPOE', 'GRUENE', 'NEOS', 'KPOE')
w2019 = within(w2019, {
abgegeben = as.integer(abgegeben)
ungueltig = as.integer(ungueltig)
gueltig = as.integer(gueltig)
nicht.waehler = Wahlberechtigte - abgegeben
kleine = KPOE + EUROPA
})
# kleine Parteien weg
w2019 = w2019[,c(-12,-13)]
omit2019 = c(1, # Kommentarzeile
grep('^G.0000', w2019$GKZ),  # BundeslÃ¤nder
grep('^G.[A-Z]', w2019$GKZ), # Bezirke
grep('^G...99', w2019$GKZ),  # Wahlkarten (sind in Summen der StÃ¤dte enthalten)
grep('^G9..01', w2019$GKZ),  # Wien ohne Wahlkarten
grep('^G[1-7]0101', w2019$GKZ), # HauptstÃ¤dte ohne Wahlkarten
grep('G10201|G30301|G40201|G30401|G40301|G20201', w2019$GKZ) # letzte Ãberbleibsel
)
at2019 = w2019[2,]
w2019 = w2019[-omit2019,] # ohne Summenzeilen
# JOIN
wahlen = merge(w2014, w2019, by='GKZ', suffixes=c('14','19'))
# Steiermark
stmk = wahlen[grep('^G6', wahlen$GKZ),]
stmk$groesse = factor(ifelse(stmk$Wahlberechtigte14 < 1200, 'klein',
ifelse(stmk$Wahlberechtigte14 < 5000, 'mittel', 'gross')))
# Aufteilen in 2 Gruppen
set.seed(12)
bekannt = sample.int(nrow(stmk), 100)
# JAGS vertrÃ¤gt keine Variablen, die Zeichenketten sind
data.columns = grep('^([^G]|GR)', colnames(stmk))
stmk.bek = stmk[bekannt, data.columns]
stmk.unbek = stmk[-bekannt, data.columns]
stmk.bek.name = stmk$Gebietsname19[bekannt]
stmk.unbek.name = stmk$Gebietsname19[-bekannt]
# Erstes Modell
modell1 = "
data {
N <- length(GKZ[])
sdOEVP = sd(OEVP14)
sdSPOE = sd(SPOE14)
sdFPOE = sd(FPOE14)
sdGRUENE = sd(GRUENE14)
sdNEOS = sd(NEOS14)
sdKleine = sd(kleine14)
sdNW = sd(nicht.waehler14)
}
model {
for (i in 1:N) {
__[i] ~ dnorm(mu[i], 1/sigma^2)
mu[i] <- intercept +
beta.oevp*OEVP14[i] +
beta.spoe*SPOE14[i] +
beta.fpoe*FPOE14[i] +
beta.gruene*GRUENE14[i] +
beta.neos*NEOS14[i] +
beta.kleine*kleine14[i] +
beta.nw*nicht.waehler14[i]
}
sigma ~ dexp(3/___)
intercept ~ dnorm(0, 1/(___)^2)
beta.oevp ~ dnorm(0, 1/(___)^2)
beta.spoe ~ dnorm(0, 1/(___)^2)
beta.fpoe ~ dnorm(0, 1/(___)^2)
beta.gruene ~ dnorm(0, 1/(___)^2)
beta.neos ~ dnorm(0, 1/(___)^2)
beta.kleine ~ dnorm(0, 1/(___)^2)
beta.nw ~ dnorm(0, 1/(___)^2)
}
"
# Erstes Modell
modell1 = "
data {
N <- length(GKZ[])
sdOEVP = sd(OEVP14)
sdSPOE = sd(SPOE14)
sdFPOE = sd(FPOE14)
sdGRUENE = sd(GRUENE14)
sdNEOS = sd(NEOS14)
sdKleine = sd(kleine14)
sdNW = sd(nicht.waehler14)
sdOEVP19 = sd(OEVP19)
maxOEVP19 = max(OEVP19)
}
model {
for (i in 1:N) {
OEVP19[i] ~ dnorm(mu[i], 1/sigma^2)
mu[i] <- intercept +
beta.oevp*OEVP14[i] +
beta.spoe*SPOE14[i] +
beta.fpoe*FPOE14[i] +
beta.gruene*GRUENE14[i] +
beta.neos*NEOS14[i] +
beta.kleine*kleine14[i] +
beta.nw*nicht.waehler14[i]
}
sigma ~ dexp(3/(2*sdOEVP19))
intercept ~ dnorm(0, 1/(3*maxOEVP19)^2)
beta.oevp ~ dnorm(0, 1/(2*sdOEVP19/sdOEVP)^2)
beta.spoe ~ dnorm(0, 1/(2*sdOEVP19/sdSPOE)^2)
beta.fpoe ~ dnorm(0, 1/(2*sdOEVP19/sdFPOE)^2)
beta.gruene ~ dnorm(0, 1/(2*sdOEVP19/sdGRUENE)^2)
beta.neos ~ dnorm(0, 1/(2*sdOEVP19/sdNEOS)^2)
beta.kleine ~ dnorm(0, 1/(2*sdOEVP19/sdKleine)^2)
beta.nw ~ dnorm(0, 1/(2*sdOEVP19/sdNW)^2)
}
"
m1 = run.jags(modell1,
monitor=c('intercept', 'sigma',
'beta.oevp', 'beta.spoe', 'beta.fpoe', 'beta.gruene',
'beta.neos', 'beta.kleine', 'beta.nw'),
data=stmk.bek,
n.chains = 3)
# Erstes Modell
modell1 = "
data {
N <- length(Wahlberechtigte14[])
sdOEVP = sd(OEVP14)
sdSPOE = sd(SPOE14)
sdFPOE = sd(FPOE14)
sdGRUENE = sd(GRUENE14)
sdNEOS = sd(NEOS14)
sdKleine = sd(kleine14)
sdNW = sd(nicht.waehler14)
sdOEVP19 = sd(OEVP19)
maxOEVP19 = max(OEVP19)
}
model {
for (i in 1:N) {
OEVP19[i] ~ dnorm(mu[i], 1/sigma^2)
mu[i] <- intercept +
beta.oevp*OEVP14[i] +
beta.spoe*SPOE14[i] +
beta.fpoe*FPOE14[i] +
beta.gruene*GRUENE14[i] +
beta.neos*NEOS14[i] +
beta.kleine*kleine14[i] +
beta.nw*nicht.waehler14[i]
}
sigma ~ dexp(3/(2*sdOEVP19))
intercept ~ dnorm(0, 1/(3*maxOEVP19)^2)
beta.oevp ~ dnorm(0, 1/(2*sdOEVP19/sdOEVP)^2)
beta.spoe ~ dnorm(0, 1/(2*sdOEVP19/sdSPOE)^2)
beta.fpoe ~ dnorm(0, 1/(2*sdOEVP19/sdFPOE)^2)
beta.gruene ~ dnorm(0, 1/(2*sdOEVP19/sdGRUENE)^2)
beta.neos ~ dnorm(0, 1/(2*sdOEVP19/sdNEOS)^2)
beta.kleine ~ dnorm(0, 1/(2*sdOEVP19/sdKleine)^2)
beta.nw ~ dnorm(0, 1/(2*sdOEVP19/sdNW)^2)
}
"
m1 = run.jags(modell1,
monitor=c('intercept', 'sigma',
'beta.oevp', 'beta.spoe', 'beta.fpoe', 'beta.gruene',
'beta.neos', 'beta.kleine', 'beta.nw'),
data=stmk.bek,
n.chains = 3)
view(m1)
diagMCMC(m1$mcmc, 'beta.neos')
#z-transformieren und gruppenvariablen in integer verwanden - ALL IN ONE Befehl :)
stmk.bek.z = prepare.df.bayes(stmk.bek, drop.originals = TRUE)
m1z = run.jags(modell1,
monitor=c('intercept', 'sigma',
'beta.oevp', 'beta.spoe', 'beta.fpoe', 'beta.gruene',
'beta.neos', 'beta.kleine', 'beta.nw'),
data=stmk.bek.z,
n.chains = 3)
view(m1z)
stmk.bek.lz = zscale.df(log2(stmk.bek + 1))
stmk.bek.lz = zscale.df(log2(stmk.bek[. -23] + 1))
stmk.bek.lz = zscale.df(log2(stmk.bek[, -23] + 1))
stmk.bek.lz = zscale.df(log2(stmk.bek[, -23] + 1), drop.originals = TRUE)
m1lz = run.jags(modell1,
monitor=c('intercept', 'sigma',
'beta.oevp', 'beta.spoe', 'beta.fpoe', 'beta.gruene',
'beta.neos', 'beta.kleine', 'beta.nw'),
data=stmk.bek.lz,
n.chains = 3)
view(m1lz)
diagMCMC(m1lz$mcmc, 'beta.neos')
stmk.unbek.lz = zscale.df.other(log2(stmk.unbek[, -23]+1), stmk.bek.lz)
#Neuer Befehl um Daten zu transformieren wie einen anderen Datensatz!
stmk.unbek.lz = zscale.df.other(log2(stmk.unbek[, -23]+1), stmk.bek.lz, drop.originals = TRUE)
# Zweites Modell
modell2 = "
model {
for (i in 1:100) {
OEVP19[i] ~ dnorm(mu[i], 1/sigma^2)
mu[i] <- beta.oevp*OEVP14[i] +
beta.spoe*SPOE14[i] +
beta.fpoe*FPOE14[i] +
beta.gruene*GRUENE14[i] +
beta.neos*NEOS14[i] +
beta.kleine*kleine14[i] +
beta.nw*nicht.waehler14[i]
}
for (i in 101:171) {
OEVP19.hat[i-100] ~ dnorm(mu[i], 1/sigma^2)
mu[i] <- beta.oevp*OEVP14[i] +
beta.spoe*SPOE14[i] +
beta.fpoe*FPOE14[i] +
beta.gruene*GRUENE14[i] +
beta.neos*NEOS14[i] +
beta.kleine*kleine14[i] +
beta.nw*nicht.waehler14[i]
}
sigma ~ dexp(3/2
beta.oevp ~ dnorm(0, 1/2^2)
beta.spoe ~ dnorm(0, 1/2^2)
beta.fpoe ~ dnorm(0, 1/2^2)
beta.gruene ~ dnorm(0, 1/2^2)
beta.neos ~ dnorm(0, 1/2^2)
beta.kleine ~ dnorm(0, 1/2^2)
beta.nw ~ dnorm(0, 1/2^2)
}
"
m2lz = run.jags(modell2,
monitor=c('sigma',
'beta.oevp', 'beta.spoe', 'beta.fpoe', 'beta.gruene',
'beta.neos', 'beta.kleine', 'beta.nw', 'OEVP19.hat'),
data=rbind(stmk.bek.lz, stmk.unbek.lz),
n.chains = 3)
# Zweites Modell
modell2 = "
model {
for (i in 1:100) {
OEVP19[i] ~ dnorm(mu[i], 1/sigma^2)
mu[i] <- beta.oevp*OEVP14[i] +
beta.spoe*SPOE14[i] +
beta.fpoe*FPOE14[i] +
beta.gruene*GRUENE14[i] +
beta.neos*NEOS14[i] +
beta.kleine*kleine14[i] +
beta.nw*nicht.waehler14[i]
}
for (i in 101:171) {
OEVP19.hat[i-100] ~ dnorm(mu[i], 1/sigma^2)
mu[i] <- beta.oevp*OEVP14[i] +
beta.spoe*SPOE14[i] +
beta.fpoe*FPOE14[i] +
beta.gruene*GRUENE14[i] +
beta.neos*NEOS14[i] +
beta.kleine*kleine14[i] +
beta.nw*nicht.waehler14[i]
}
sigma ~ dexp(3/2
beta.oevp ~ dnorm(0, 1/(2)^2)
beta.spoe ~ dnorm(0, 1/2^2)
beta.fpoe ~ dnorm(0, 1/2^2)
beta.gruene ~ dnorm(0, 1/2^2)
beta.neos ~ dnorm(0, 1/2^2)
beta.kleine ~ dnorm(0, 1/2^2)
beta.nw ~ dnorm(0, 1/2^2)
}
"
#Neuer Befehl um Daten zu transformieren wie einen anderen Datensatz!
stmk.unbek.lz = zscale.df.other(log2(stmk.unbek[, -23]+1), stmk.bek.lz, drop.originals = TRUE)
m2lz = run.jags(modell2,
monitor=c('sigma',
'beta.oevp', 'beta.spoe', 'beta.fpoe', 'beta.gruene',
'beta.neos', 'beta.kleine', 'beta.nw', 'OEVP19.hat'),
data=rbind(stmk.bek.lz, stmk.unbek.lz),
n.chains = 3)
# Zweites Modell
modell2 = "
model {
for (i in 1:100) {
OEVP19[i] ~ dnorm(mu[i], 1/sigma^2)
mu[i] <- beta.oevp*OEVP14[i] +
beta.spoe*SPOE14[i] +
beta.fpoe*FPOE14[i] +
beta.gruene*GRUENE14[i] +
beta.neos*NEOS14[i] +
beta.kleine*kleine14[i] +
beta.nw*nicht.waehler14[i]
}
for (i in 101:171) {
OEVP19.hat[i-100] ~ dnorm(mu[i], 1/sigma^2)
mu[i] <- beta.oevp*OEVP14[i] +
beta.spoe*SPOE14[i] +
beta.fpoe*FPOE14[i] +
beta.gruene*GRUENE14[i] +
beta.neos*NEOS14[i] +
beta.kleine*kleine14[i] +
beta.nw*nicht.waehler14[i]
}
sigma ~ dexp(3/2)
beta.oevp ~ dnorm(0, 1/2^2)
beta.spoe ~ dnorm(0, 1/2^2)
beta.fpoe ~ dnorm(0, 1/2^2)
beta.gruene ~ dnorm(0, 1/2^2)
beta.neos ~ dnorm(0, 1/2^2)
beta.kleine ~ dnorm(0, 1/2^2)
beta.nw ~ dnorm(0, 1/2^2)
}
"
m2lz = run.jags(modell2,
monitor=c('sigma',
'beta.oevp', 'beta.spoe', 'beta.fpoe', 'beta.gruene',
'beta.neos', 'beta.kleine', 'beta.nw', 'OEVP19.hat'),
data=rbind(stmk.bek.lz, stmk.unbek.lz),
n.chains = 3)
samples2 = as.matrix(m2lz$mcmc)
dim(sample2)
dim(samples2)
stmk.samples = samples2[, -(1:8)]
gemeinde = 37
gem.samples = stmk.samples[, gemeinde]
stmk.unbek.name[gemeinde]
gem.orig = inv.zscale.other(gem.samples, stmk.bek.lz$OEVP19)
gem.orig = 2^gem.orig - 1
gem.orig
plotPost(gem.orig, compVal = stmk.unbek$OEVP19[gemeinde])
